"""
This script contains the class LigEfficiency.

This is used to rescore a fitness metric by the number of non-hydrogen atoms.
"""
import __future__
from typing import Any, Dict, List, Optional

from autogrow.types import Compound
from autogrow.docking.scoring.scoring_classes.parent_scoring_class import ParentScoring
from autogrow.docking.scoring.scoring_classes.scoring_functions.vina import VINA
from autogrow.plugins.plugin_manager_instances import plugin_managers

# TODO: Not used anywhere, but good stuff here!


class LigEfficiency(VINA):
    """
    Scores a given ligand for its binding affinity per VINA, QuickVina02, etc.

    This inherits many functions from the vina scoring function. The only
    difference is that this scoring function uses the ligand efficiency
    instead of docking score. ligand efficiency is the docking score divided
    by the number of heavy atoms (non-hydrogens)

    Inputs:
    :param class VINA: the VINA scoring function which this class inherits
        from.
    """

    def __init__(
        self,
        params: Optional[Dict[str, Any]] = None,
        smiles_dict: Optional[Dict[str, List[str]]] = None,
        test_boot: bool = True,
    ) -> None:
        """
        Initialize the class with the given parameters.

        Inputs:
        :param dict params: Dictionary of User variables
        :param dict smiles_dict: a dict of ligand info of SMILES, IDS, and
            short ID
        :param bool test_boot: used to initialize class without objects for
            testing purpose
        """
        if not test_boot:
            self.params = params

            self.smiles_dict = smiles_dict

    def set_lig_eff_rescore_from_a_file(
        self, file_path: str, lig_info: Compound
    ) -> Optional[Compound]:
        """
        Add ligand efficiency score to end of lig_info list and return the list.

        The last value of the lig_info list must be a float.

        Inputs:
        :param str file_path: the path to the file to be scored
        :param list lig_info: a list of the ligands id_name and
            the fitness score from the best pose.
            This would have been generated by the primary method of
            scoring/rescoring

        Returns:
        :returns: list lig_info: a list of the ligands id_name and
            the docking score from the best pose.
        """
        # For saftey remove Nones and empty lists
        if type(lig_info) is not Compound:
            return None
        if not lig_info:
            return None

        return score_as_lig_efficiency(lig_info)
        # lig_info_with_score = [str(x) for x in lig_info_with_score]


# These Functions are placed outside the class for multithreading reasons.
# Multithreading doesn't like being executed within the class.


def get_number_heavy_atoms(smiles_str: Optional[str]) -> Optional[int]:
    """
    Get the number of non Hydrogens in a SMILES string.

    Inputs:
    :param str smiles_str: a str representing a molecule

    Returns:
    :returns: int num_heavy_atoms: a int of the count of heavy atoms
    """
    if smiles_str is None:
        return None
    # easiest nearly everything should get through

    chemtoolkit = plugin_managers.ChemToolkit.toolkit

    try:
        mol = chemtoolkit.mol_from_smiles(smiles_str, sanitize=False)
    except Exception:
        mol = None

    if mol is None:
        return None

    atom_list = chemtoolkit.get_atoms(mol)
    num_heavy_atoms = 0
    for atom in atom_list:
        if chemtoolkit.get_atomic_num(atom) != 1:
            num_heavy_atoms = num_heavy_atoms + 1

    return num_heavy_atoms


def score_as_lig_efficiency(list_of_lig_info: Compound,) -> Optional[Compound]:
    """
    Determine the ligand efficiency and set it to be the code.

    Inputs:
    :param list list_of_lig_info: a list containing ligand informations with
        idx=0 as the SMILES str and idx=-1 is the docking score

    Returns:
    :returns: list list_of_lig_info: the same list as list_of_lig_info, but
        with each sublist now having the ligand efficiency score appended to the
        end.
    """
    if list_of_lig_info is None:
        return None

    # if type(list_of_lig_info) is None:
    #     return None
    # elif type(list_of_lig_info) == CompoundInfo2:
    #     if None in list_of_lig_info:
    #         return None

    # Unpack ligand info
    lig_smiles_str = list_of_lig_info.smiles
    affinity = list_of_lig_info.docking_score

    # Get num of heavy atoms
    heavy_atom_count = get_number_heavy_atoms(lig_smiles_str)

    if heavy_atom_count is None or heavy_atom_count == 0:
        return None

    # Convert to Lig efficiency (aka affinity/heavy_atom_count )
    lig_efficieny = affinity / float(heavy_atom_count)

    # Append lig_efficiency to list_of_lig_info
    list_of_lig_info.docking_score = lig_efficieny

    return list_of_lig_info
